Modular Kotlin/Java Library Gradle Project
==========================================

How to set up a Gradle project that uses JPMS modules and that can be used for mixed Kotlin/Java coding.

**JPMS = Java Platform Module System** (introduced with Java 9, aka "Project Jigsaw")

Versions Used
-------------

- Gradle 8.7
- Kotlin 1.9.23
- Java 21
- IntelliJ IDEA 2023.3.5, Build #IU-233.14808.21, built on March 12, 2024

Gradle (Step 1)
---------------

```
mkdir jpms-library
cd jpms-library/
```

Set JAVA_HOME to the desired JDK.

Generate a Gradle library project with `./gradlew init --package com.staticnoiselog`:

- type of project: library
- implementation language: Kotlin
- build script DSL: Kotlin
- project name: jpms-library

This way of project initialization should already use a `toolchain` in the build script.

    ./gradlew clean build

IntelliJ (Step 2)
-----------------

Open project in IntelliJ.
Check/fix the project SDK version.

### First Module

First we convert the existing "lib" into a JPMS module.

Unfortunately, the `module-info.java` only seems to work if it is in the `src/main/java` directory. So we have to create
that directory first.

In IntelliJ, right-click on `src/main`, New, Directory
-> IntelliJ offers "Gradle Source Sets java". Select this.

Right-click on the newly created `java` subdirectory, New, `module-info.java`

Choose a good name for the first module as this how your library will be seen by users. The "kotlin.stdlib" module is
required.

    module jpms.library.lib {
        requires kotlin.stdlib;
    }

### Add Second Module

To add a second module we have to add a Gradle subproject and convert that into a JPMS module, too.

**In IntelliJ:**

- Right-click on the project's root directory: New, Module...
- Prefer underscores for the name of modules: long_module_name
  (dashes are technically OK, but snake_case is preferable for subdirectories)
- Language: Kotlin
- Build System: Gradle
- JDK: the actual JDK you are using for your project
- Gradle DSL: Kotlin
- Under "Advanced Settings" you can change "GroupId" to set a package name.
- Ignore a possible warning "Unsupported Project JDK" and proceed.

Use the `build.gradle.kts` build script of the first module created by Gradle as a template for adapting the new
module's `build.gradle.kts` generated by IntelliJ. In particular, replace `kotlin("jvm") version "..."` with
`alias(libs.plugins.jvm)` in order to make use of `libs.versions.toml` and make sure to add the `java-library` plugin.

Note how an additional `include` was added to `settings.gradle.kts` for the new module.

Now we convert this new module into a JPMS module. Just as with the first module, we have to create `module-info.java`
in the `src/main/java` directory. So we have to create that directory first.

In IntelliJ, right-click on `src/main`, New, Directory
-> IntelliJ offers "Gradle Source Sets java". Select this.

Right-click on the newly created `java` subdirectory, New, `module-info.java`

    module jpms.library.deeplearning {
        requires kotlin.stdlib;
    }

**Manually:**

- create directory for new module
- create directory structure with `src/main/kotlin` and `src/main/java`
- add new module to `settings.gradle.kts` (`include("deeplearning")`)
- copy over `build.gradle.kts` from an existing module

**Referring to the Second Module from the First Module**

In `build.gradle.kts` of the first module, add the following line to the dependencies:

    implementation(project(":deeplearning"))

### Renaming a Module

Don't do this in IntelliJ, it does not work with version 2023.3.5. Instead, close IntelliJ and rename the Gradle
subproject that corresponds with the module manually.

1. **Rename the Directory**: First, rename the directory of the subproject.
2. **Update `settings.gradle.kts`**: Update the subproject name in the parent project's `settings.gradle.kts` file.
3. **Update Project References**: Update the subproject name where it was mentioned in build scripts
   like `build.gradle.kts` or other Gradle files.
4. **Sync Gradle**: Synchronize the Gradle files by running `./gradlew --refresh-dependencies` in the terminal.

### Deleting a Module

You can try deleting the module in IntelliJ's Project Structure (Ctrl+Alt+Shift+S), then deleting the directory and
finally removing any references to the module from files. Or you do it without IntelliJ, analogous to renaming a
module, keeping in mind that a module corresponds to a subproject in Gradle.

Convention Plugin, buildSrc
---------------------------

In a more complex project you may run into this Gradle warning:

*The Kotlin Gradle plugin was loaded multiple times in different subprojects, which is not supported and may break the
build.*

By centralizing the build configuration in a convention plugin ([buildSrc](buildSrc)), this warning can be avoided.

Convention plugins are the recommended way to share build logic across Gradle subprojects. So aside from getting rid of
the warning, we also make the build more maintainable. For instance, the JDK version does not have to be set in every
subproject, but is centralized in the convention plugin.

A quick overview how to set up a convention plugin (if you need up-to-date templates for these files, you can
use `gradlew init` to create a new example project and copy the files from there):

- Create a new directory [buildSrc](buildSrc) in the root of the project.
- Add [settings.gradle.kts](buildSrc%2Fsettings.gradle.kts). Note how the version
  catalog ([libs.versions.toml](gradle%2Flibs.versions.toml)) from the main build is reused.
- Add [build.gradle.kts](buildSrc%2Fbuild.gradle.kts), the build script for the convention plugins
  in [buildSrc](buildSrc).
- Create the [buildSrc/src/main/kotlin](buildSrc%2Fsrc%2Fmain%2Fkotlin) directory and add one our more convention
  plugins there.
  The [jpms-library.shared-conventions.gradle.kts](buildSrc%2Fsrc%2Fmain%2Fkotlin%2Fjpms-library.shared-conventions.gradle.kts)
  convention plugin is an example that, among some other common tasks, applies the Gradle JVM plugin for Kotlin and sets
  the Java toolchain.
- Apply the convention plugin in the subprojects' build scripts. For instance, in
  the [build.gradle.kts](lib%2Fbuild.gradle.kts) of the `lib` subproject, add `id("jpms-library.shared-conventions")` in
  the `[plugins]` section.

Gradle JVM Plugin for Kotlin
----------------------------

`org.jetbrains.kotlin.jvm` is the **Gradle JVM plugin** for building Kotlin projects that target a JVM without Android
support. It provides tasks for compiling Kotlin code to JVM bytecode and also includes the standard Kotlin library in
the project dependencies. This plugin offers integration with the Gradle `java` plugin (as well as `java-library`
or `application`).

The following was observed with Gradle 8.7:

When you generate a Gradle library project with `gradlew init`, the Gradle JVM plugin is applied
with `alias(libs.plugins.jvm)`. The "alias" syntax adds a plugin dependency using a notation coming from a version
catalog. In this case, it references an entry in the `[plugins]` section of `libs.versions.toml`:

    [plugins]
    jvm = { id = "org.jetbrains.kotlin.jvm", version = "1.9.23" }

However, the `alias(libs.plugins.jvm)` syntax cannot be used when coding your own convention plugin in `buildSrc`, like
[jpms-library.shared-conventions.gradle.kts](buildSrc%2Fsrc%2Fmain%2Fkotlin%2Fjpms-library.shared-conventions.gradle.kts).
Instead, you have to use the "id" syntax, for example `id("org.jetbrains.kotlin.jvm")`. Somewhat confusingly, the syntax
with "id" refers to an entry in the `[libraries]` section in the version catalog, not the `[plugins]` section.
Therefore, in the `buildSrc` context, the `libs.versions.toml` file should contain an entry like this under
the `[libraries]` section:

    [libraries]
    kotlin-gradle-plugin = { module = "org.jetbrains.kotlin:kotlin-gradle-plugin", version = "1.9.23" }

Bottom line: If you can use `alias(libs.plugins.jvm)` you need an entry in the `[plugins]` section
of `libs.versions.toml` and with `id("org.jetbrains.kotlin.jvm")` you need an entry in the `[libraries]` section. You
need only one of these.

Mixing Kotlin and Java Code
---------------------------

These remarks are based on the experience with Gradle 8.7 and Kotlin 1.9.23.

### Separate Source Sets

Kotlin code must go into `src/main/kotlin` and Java code into `src/main/java`. It may look like Java code can be placed
in the Kotlin source set, alongside Kotlin code, but in fact the Java files will simply be ignored. So stick to the
clean separation.

### Referencing Kotlin Code from Java

With Gradle 8.7, Kotlin code is not visible to Java code in the same module. To make Kotlin code visible to Java code,
as demonstrated in [JavaUsesKotlin.java](lib%2Fsrc%2Fmain%2Fjava%2Fcom%2Fstaticnoiselog%2FJavaUsesKotlin.java), you have
to add this snippet to [build.gradle.kts](lib%2Fbuild.gradle.kts) as a workaround:

```
tasks.compileJava {
    options.compilerArgumentProviders.add(object : CommandLineArgumentProvider {
        @CompileClasspath
        val kotlinClasses = kotlin.sourceSets.main.flatMap { it.kotlin.classesDirectory }

        override fun asArguments() = listOf(
            "--patch-module",
            "jpms.library.lib=${kotlinClasses.get().asFile.absolutePath}"
        )
    })
}
```

For older Kotlin versions it might be necessary to make this change:

```
        // work-around for Kotlin Gradle Plugin <1.8.20 not setting the classDirectory properly
        //val kotlinClasses = kotlin.sourceSets.main.flatMap { it.kotlin.classesDirectory }
        val kotlinClasses = tasks.compileKotlin.flatMap { it.destinationDirectory }
}
```

For more information,
see [this topic in the Gradle Forums](https://discuss.gradle.org/t/mixing-kotlin-and-java-in-a-jpms-module-gradle-project/48011/3).

JUnit 5
-------

Three dependencies are included to utilize JUnit 5. The first one, `org.jetbrains.kotlin:kotlin-test-junit5`, provides
JUnit 5 integration for Kotlin and is required for writing JUnit tests in Kotlin.

You may be able to run JUnit tests in IntelliJ without the other two dependencies, likely because IntelliJ already
includes these libraries. However, when you create a Gradle project with `gradlew init`, all three dependencies are
included. To prevent potential issues, such as when running tests on a build pipeline, it's recommended to include the
other two dependencies as well.

```
dependencies {
    testImplementation(libs.kotlin.test.junit5) // JUnit 5 integration for Kotlin
    testRuntimeOnly(libs.junit.jupiter.engine) // JUnit 5 engine for running tests
    testRuntimeOnly(libs.junit.platform.launcher) // JUnit 5 support for IDEs and build tools
}
```

Troubleshooting
---------------

### package is empty or does not exist

If the build produces errors for `module-info.java` like "package is empty or does not exist", try creating the package
stated in the error message under the `src/main/java` directory and add a minimal Java dummy file to it, something like
this:

    class Unused {
    }